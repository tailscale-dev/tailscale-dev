---
title: 'Introducing the Tailscale Universal Docker Mod'
date: 9999-12-31
authors: ['xe']
tags:
  - docker
  - philosophy
summary: "We created a universal Docker mod for Tailscale, which lets you slap tailscale in on the side of existing Docker containers. In this article, Xe explains how you can use this and why it's funny."
---

If you use Docker containers from [linuxserver.io](https://linuxserver.io), you can seamlessly add Tailscale to them using our new [universal Docker mod](TODO://Xe/fixme). This lets you graft Tailscale into the existing linuxserver.io containers so you can use Tailscale to access the services, let you SSH into a container, serve those services over HTTPS to your tailnet, or even to the world with Funnel.

To add this to your existing Docker containers with linuxserver.io images, add the following environment variables to your docker-compose.yml file:

```yaml
- DOCKER_MODS=ghcr.io/xe/ts-mod:latest # TODO, change this to the real URL
# tailscale information
- TS_STATE_DIR=/var/lib/tailscale # make sure this is persisted in a volume
- TAILSCALE_SERVE_PORT=80
- TAILSCALE_SERVE_MODE=https
## uncomment to enable funnel
#- TAILSCALE_FUNNEL=on
- TS_USE_SSH=1
- TS_HOSTNAME=wiki
- TS_AUTHKEY=tskey-auth-hunter2CNTRL-hunter2hunter2 # TODO(user): replace this with your authkey from the admin panel
```

This will add Tailscale to a [dokuwiki](https://fleet.linuxserver.io/image?name=linuxserver/dokuwiki) container so that you can access it over your tailnet. If you run `docker compose up -d` with the authkey changed out for [a valid authkey](https://login.tailscale.com/admin/settings/keys), you'll be able to access your dokuwiki instance over Tailscale.

In general, these are the environment variables you need to set to configure this:

These variables will be explained in detail below. The rest of this article is going to describe some more fun things about using it, and why I think docker mods are kind of funny from a philosophical sense.

## What is humor?

Before we get into the meat of what a Docker mod is, I want to start with a bit of a lighter topic: the philosophy of humor.

Humor is a complicated concept that is almost universal throughout human cultures. It's a way of conveying concepts like absurdity, irony, the absurdity of irony, and normally frustrating things in ways that aren't quite as much of a downer. It's really about being able to communicate subtle things like common errors that everyone makes when learning things (such as English and its rule of all the rules having exceptions, even for the exceptions). It's also a tool that you can use to help describe the abstract and nonphysical things like emotions, feelings, ideas, the human condition, and how Kubernetes works.

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  Humor is also really hard to convey properly in a written medium. This is even more difficult when
  the humor is about technology, which is usually hard to understand in the first place. I'm going
  to try to explain the humor in this article with these asides so that y'all can follow along, but
  if you already get why this is funny it may ruin the joke for you. Sorry!
</ConvSnippet>

In his famous presentation [Reverse emulating the NES](https://youtu.be/ar9WRwCiSr0), fellow philosopher in arms [tom7](http://tom7.org/) introduced the idea of a type of humor called "invalid hierarchies". In this he does rather abusrd things to an NES using a custom circuit board and a raspbery pi to allow him to (among other things) run an SNES emulator on the NES. This video is quite possibly one of my favorite technical communication videos and is a huge influence to how I write humorous things for this blog.

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  This creates an invalid hierarchy because you expect the NES to only run 8-bit NES games, but not
  16-bit SNES games. This is funny. If you've never seen that video before, it's well worth a watch.
  <br />
  Another example of an invalid hierarchy is my April Fool's Day post [Using Tailscale without using
  Tailscale](https://tailscale.dev/blog/headscale-funnel). You'd expect to have to use Tailscale if
  you want to use Tailscale, but "using Tailscale without using Tailscale" creates an invalid
  hierarchy in the mind of the reader. This is also funny.
</ConvSnippet>

<Image
  className="mx-auto"
  src="/images/universal-docker-mod/nes-snes.svg"
  width={359}
  height={490}
  alt="The expected hierarchies of NES and SNES consoles and their games"
/>

## Docker

Docker allows you to create snapshots of operating system installs with a given state, such as "having the [Go](https://go.dev) compiler available" or "install this program and all its dependencies" and distribute those preconfigured images on the Internet. When you consume the same Docker image at two time intervals T0 and T1, you get the same image with the same code, just as you expect.

When a Docker container is run, it usually runs on top of an ephemeral filesystem that gets destroyed when the container is stopped. This means that restarting the container will reset it back to the state that was there when the image was created. This is normally convenient when working on applications that make temporary changes to the filesystem, such as an image converter that uses temporary files to do the conversion logic.

This is less convenient when you want to run things like database servers in Docker. However, most of the time when you do things that need persistent state, that persistent state is usually limited to a single file or directory. Docker provides external persistent state with [volumes](https://docs.docker.com/storage/volumes/). They're basically directories that are plunked into the container at runtime, but it maintains the state between container runs. This is great for things like databases because you wouldn't want to lose all your data when you restart the container.

<Image
  className="mx-auto"
  src="/images/universal-docker-mod/docker-normal.svg"
  width={623}
  height={490}
  alt="The expected hierarchies of Docker containers and their statefulness"
/>

So, from here we can create a hierarchy for docker and statefulness. You expect docker containers to have state for _data_, and you also expect the docker container to be running the same code every time you run the same image. You don't expect anything else to be running, everything is deterministic at T0, T1, or TN.

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  This is a valid hierarchy because it's what you expect from docker. You expect the same code to
  run every time you run the same image.
</ConvSnippet>

Docker also has an [`ONBUILD`](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#onbuild) hook that lets you declare a series of commands that are automagically executed when the image is customized. You can use this to create a base image that has Go and Node.js installed so you can automagically build your code without any extra steps.

This is amazingly useful when in prescriptivist ecosystems like Ruby on Rails or such things, because the install commands are _almost always identical_, allowing you to get all of the benefits of a docker image without the cognitive complexity having to write a custom dockerfile for every single project.

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  It's slightly sad to see this not used as much anymore. It's amazingly conveninent, but it's also
  a great way to hang yourself. The `ONBUILD` hooks run before your Dockerfile directives run, so if
  you run into a case where you _absolutely have to_ install an arbitrary dependency (IE: the Go
  compiler in a Rails app), you're out of luck.
</ConvSnippet>

## Docker mods

Docker mods let you install extra packages and services into containers at runtime. If the `ONBUILD` hook lets you run a series of commands when an image is built, you can think of docker mods as a missing `ONRUN` hook that lets you customize an image at runtime.

<Image
  className="mx-auto"
  src="/images/universal-docker-mod/docker-mod.svg"
  width={703}
  height={716}
  alt="How Docker mods change the statefulness of a container"
/>

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  This creates an invalid hierarchy because we think about the code in a container being
  deterministic between invocations and this allows you to make something _nondeterministic_. This
  is funny.
</ConvSnippet>

### Docker mods and s6

At a high level, a docker mod is a series of files that add additional instructions to the start phase of a docker container. It works because the [linuxserver.io](https://www.linuxserver.io/) containers preinstall [s6](https://skarnet.org/software/s6/) via [s6-overlay](https://github.com/just-containers/s6-overlay) and then start it in the background to manage the lifecycle of services in the container.

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  This is also funny because usually Docker containers aren't supposed to have multiple processes
  running in them for simplicity, but it turns out that when you want to do things like put your
  wiki seamlessly on your tailnet, you want to have multiple processes running. This is another
  invalid hierarchy because you expect the container to only have one process running, but it has
  multiple with a service manager, just like the host OS.
</ConvSnippet>

When I made the docker mod, I had to create a few s6 services to help it run:

- One to set a list of packages that Tailscale needs to run ([jq](https://stedolan.github.io/jq/) to process some data from the packages server, and [iptables](https://linux.die.net/man/8/iptables) to configure the firewall inside the container for Tailscale to run in a [TUN](https://en.wikipedia.org/wiki/TUN/TAP) device).
- One to download Tailscale to the container.
- One to start the Tailscale node agent `tailscaled`.
- One to authenticate you to the tailnet with [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up/) and set other settings like [`tailscale serve`](https://tailscale.com/kb/1242/tailscale-serve/).

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  This is also hilarious because this roughly mirrors the process that you have to do on your host
  OS to get Tailscale running. This is another layer of invalid hierarchy because you expect
  containers to ship with all the software they need, but here is this container that needs to
  download software at runtime. This is funny because it's like a container that needs to download
  software at runtime, just like your host OS. As above, so below, eh?
</ConvSnippet>

Each of these is connected together like this (arrows indicate dependencies):

<Image
  className="mx-auto"
  src="/images/universal-docker-mod/s6.svg"
  width={318}
  height={550}
  alt="The s6 dependency web"
/>

<ConvSnippet authors={props.authorDetails} name="Xe Iaso">
  If you've ever worked deeply with the Heroku ecosystem, you can think about Docker mods as akin to
  all of the hilarous hacks you can do with buildpacks at dyno boot time.
</ConvSnippet>

```yaml
# docker-compose.yaml
version: '2.1'
services:
  dokuwiki:
    image: lscr.io/linuxserver/dokuwiki:latest
    container_name: dokuwiki
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Etc/UTC
      - DOCKER_MODS=ghcr.io/xe/ts-mod:latest
      # tailscale information
      - TS_STATE_DIR=/var/lib/tailscale
      - TAILSCALE_SERVE_PORT=80
      - TAILSCALE_SERVE_MODE=https
      ## uncomment to enable funnel
      #- TAILSCALE_FUNNEL=on
      - TS_USE_SSH=1
      - TS_HOSTNAME=wiki
      - TS_AUTHKEY=tskey-auth-hunter2CNTRL-hunter2hunter2

    volumes:
      - dokuwiki-data:/config
      - dokuwiki-tailscale:/var/lib/tailscale
    restart: unless-stopped

volumes:
  dokuwiki-data:
  dokuwiki-tailscale:
```

## Configuration

The Docker mod exposes a bunch of environment variables that you can use to configure it. You can see the full list of environment variables in the [documentation](TODO://Xe/link), but here are the important ones:

| Environment Variable   | Description                                                                                                                                                                                                                                                                                                   | Example                                  |
| :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------- |
| `TS_STATE_DIR`         | The directory where the Tailscale state will be stored, this should be pointed to a Docker volume. If it is not, then the node will set itself as ephemeral, making the node disappear from your tailnet when the container exits.                                                                            | `/var/lib/tailscale`                     |
| `TS_AUTHKEY`           | The authkey for your tailnet. You can create one in the [admin panel](https://login.tailscale.com/admin/settings/keys). See [here](https://tailscale.com/kb/1085/auth-keys/) for more information about authkeys and what you can do with them.                                                               | `tskey-auth-hunter2CNTRL-hunter2hunter2` |
| `TS_HOSTNAME`          | The hostname that you want to set for the container. If you don't set this, the hostname of the node on your tailnet will be a bunch of random hexadecimal numbers, which many humans find hard to remember.                                                                                                  | `wiki`                                   |
| `TS_USE_SSH`           | Set this to `1` to enable SSH access to the container.                                                                                                                                                                                                                                                        | `1`                                      |
| `TAILSCALE_SERVE_PORT` | The port number that you want to expose on your tailnet. This will be the port of your DokuWiki, Transmission, or other container.                                                                                                                                                                            | `80`                                     |
| `TAILSCALE_SERVE_MODE` | The mode you want to run Tailscale serving in. This should be `https` in most cases, but there may be times when you need to enable `tls-terminated-tcp` to deal with some weird edge cases like HTTP long-poll connections. See [here](https://tailscale.com/kb/1242/tailscale-serve/) for more information. | `https`                                  |
| `TAILSCALE_FUNNEL`     | Set this to `true`, `1`, or `t` to enable [funnel](https://tailscale.com/kb/1243/funnel/). For more information about the accepted syntax, please read the [strconv.ParseBool documentation](https://pkg.go.dev/strconv#ParseBool) in the Go standard library.                                                | `on`                                     |

Something important to keep in mind is that you really should set up a separate volume for Tailscale state. Here is how to do that with the docker commandline:

```sh
docker volume create dokuwiki-tailscale
```

Then you can mount it into a container by using the volume name instead of a host path:

```yaml
volumes:
  - dokuwiki-data:/config
  - dokuwiki-tailscale:/var/lib/tailscale
```

- Configuration
  - We're going to start out by setting up a basic interactive container connected to your tailnet.
  - Enabling the docker mod
  - Setting an authkey
  - Setting a hostname for the container
  - The magic of state and why you need a volume or host mount for the tailscale state
    - If you don't set it, the container will be ephemeral by default and you'll lose your tailscale state every time you restart the container. This is undesirable if you restart the container a lot and use HTTPS serving, which requires your container to re-fetch a new HTTPS certificate on every restart. This will make you run out of Let's Encrypt rate limit calls.
  - setting a custom hostname
  - enabling SSH
    - Xe\ This is another example of an invalid hierarchy because you don't expect to be able to SSH into containers but here we are.
  - `tailscale serve` commands
  - Funnel
- Some fun things you can do
  - Set up a wiki with dokuwiki
    - TODO(Xe): copy above docker compose file
  - Set up an IRC bouncer with ZNC
    - We have an IRC channel on [libera.chat](https://libera.chat) in `#tailscale`. If you want to join, you can configure a copy of ZNC like this:
    - TODO(Xe): add basic instructions
  - Set up an exit node for your favorite VPN provider with the wireguard image
    - TODO(Xe): Test with Mullvad and write instructions
  - Set up your own code-server instance
    - TODO(Xe): write instructions
  - Check out [Awesome-LSIO](https://docs.linuxserver.io/general/awesome-lsio) for more ideas!
- Conclusion / call to action
